/// A modular voxel system designed for team deathmatch games.
///
/// This module provides core components and systems for:
/// - Voxel data representation
/// - Chunk-based world storage
/// - Efficient mesh generation with face culling
/// - Terrain generation using noise functions
/// - Integration with Bevy's ECS system
///
/// The design focuses on performance for real-time editing during gameplay,
/// which is crucial for a voxel-based TDM where the environment can change
/// dynamically during matches.
use bevy::prelude::*;
use tracing::{debug, instrument};

/// A single voxel in the world.
///
/// Voxels are the basic building blocks of our voxel-based game.
/// Each voxel has a type (air, solid, different materials) and a color.
/// For the TDM game, we can extend this with more properties like
/// durability, special effects, etc.
#[derive(Clone, Copy, Debug, PartialEq, Component)]
pub struct Voxel {
    /// Type of voxel (air, solid, special blocks)
    pub voxel_type: VoxelType,
    /// Color of voxel
    pub color: Color,
}

/// Types of voxels in our game.
///
/// This defines the different kinds of blocks that can exist in the world.
/// We'll expand this as we add more game mechanics.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum VoxelType {
    /// Air - no block, can be passed through
    Air,
    /// Basic solid block
    Solid,
    /// Destructible block (lower health)
    Destructible,
    /// Magic block (for magic-based gameplay elements)
    Magic,
}

impl Voxel {
    /// Creates a new voxel with the given type and color.
    ///
    /// # Arguments
    ///
    /// * `voxel_type` - The type of voxel to create
    /// * `color` - The color of the voxel
    ///
    /// # Returns
    ///
    /// A new Voxel instance
    pub fn new(voxel_type: VoxelType, color: Color) -> Self {
        Self { voxel_type, color }
    }

    /// Returns true if this voxel is solid (blocks movement).
    ///
    /// Air voxels are non-solid, all others are considered solid.
    pub fn is_solid(&self) -> bool {
        !matches!(self.voxel_type, VoxelType::Air)
    }
}

impl Default for Voxel {
    fn default() -> Self {
        Self {
            voxel_type: VoxelType::Air,
            color: Color::BLACK,
        }
    }
}

/// Represents a position in voxel coordinates.
///
/// Voxel coordinates use integers to represent discrete positions
/// in the voxel grid. This is different from world coordinates
/// which use floating point numbers.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct VoxelPosition {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl VoxelPosition {
    /// Creates a new voxel position.
    pub fn new(x: i32, y: i32, z: i32) -> Self {
        Self { x, y, z }
    }

    /// Converts voxel position to world coordinates.
    ///
    /// This is needed for positioning meshes in the 3D world.
    /// Voxel size is assumed to be 1.0 world units.
    pub fn to_world_position(&self) -> Vec3 {
        Vec3::new(self.x as f32, self.y as f32, self.z as f32)
    }
}

/// A chunk of voxels.
///
/// The world is divided into chunks for performance reasons.
/// Chunks allow for efficient culling and mesh generation.
/// Each chunk has a fixed size defined by CHUNK_SIZE.
#[derive(Debug, Clone)]
pub struct VoxelChunk {
    /// Position of this chunk in chunk coordinates
    pub chunk_position: ChunkPosition,
    /// The voxels in this chunk
    voxels: Vec<Voxel>,
    /// Handle to the mesh if this chunk has been rendered
    mesh_handle: Option<Handle<Mesh>>,
    /// Entity for this chunk's mesh in the ECS world
    entity: Option<Entity>,
    /// Whether this chunk needs to be remeshed
    dirty: bool,
    /// Whether this chunk has been fully generated by the terrain generator.
    /// This is used to prevent partial chunks (e.g. from trees) from stopping full generation.
    pub generated: bool,
}

/// Represents a chunk position in the world.
///
/// Chunk coordinates are used to organize chunks in the world.
/// They are different from voxel coordinates.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Component)]
pub struct ChunkPosition {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl ChunkPosition {
    /// Creates a new chunk position.
    pub fn new(x: i32, y: i32, z: i32) -> Self {
        Self { x, y, z }
    }
}

/// The size of each chunk in voxels.
///
/// This is a constant that defines how many voxels are in each dimension of a chunk.
/// 16x16x16 is a good balance between performance and memory usage.
pub const CHUNK_SIZE: usize = 16;

/// The number of voxels in a chunk (cubed).
pub const CHUNK_VOLUME: usize = CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE;

impl VoxelChunk {
    /// Creates a new empty chunk at the given position.
    ///
    /// # Arguments
    ///
    /// * `chunk_position` - The position of this chunk in chunk coordinates
    pub fn new(chunk_position: ChunkPosition) -> Self {
        Self {
            chunk_position,
            voxels: vec![Voxel::default(); CHUNK_VOLUME],
            mesh_handle: None,
            entity: None,
            dirty: true, // New chunks start dirty to trigger mesh generation
            generated: false,
        }
    }

    /// Gets a voxel at local chunk coordinates.
    ///
    /// # Arguments
    ///
    /// * `local_pos` - Local position within the chunk (0..CHUNK_SIZE)
    ///
    /// # Returns
    ///
    /// A reference to the voxel at the given position
    pub fn get_voxel(&self, local_pos: VoxelPosition) -> &Voxel {
        let index = Self::local_to_index(local_pos);
        &self.voxels[index]
    }

    /// Sets a voxel at local chunk coordinates.
    ///
    /// # Arguments
    ///
    /// * `local_pos` - Local position within the chunk (0..CHUNK_SIZE)
    /// * `voxel` - The voxel to set
    pub fn set_voxel(&mut self, local_pos: VoxelPosition, voxel: Voxel) {
        let index = Self::local_to_index(local_pos);
        self.voxels[index] = voxel;
        self.dirty = true; // Mark chunk as dirty when voxel changes
    }

    /// Converts local chunk coordinates to array index.
    ///
    /// This is used to store voxels in a flat array.
    /// Uses Z-order (Morton order) for better cache locality.
    fn local_to_index(local_pos: VoxelPosition) -> usize {
        (local_pos.z as usize * CHUNK_SIZE * CHUNK_SIZE)
            + (local_pos.y as usize * CHUNK_SIZE)
            + local_pos.x as usize
    }

    /// Converts array index to local chunk coordinates.
    ///
    /// The inverse of local_to_index.
    pub fn index_to_local(index: usize) -> VoxelPosition {
        VoxelPosition {
            x: (index % CHUNK_SIZE) as i32,
            y: ((index / CHUNK_SIZE) % CHUNK_SIZE) as i32,
            z: (index / (CHUNK_SIZE * CHUNK_SIZE)) as i32,
        }
    }

    /// Gets the world position of this chunk.
    ///
    /// Converts chunk coordinates to world coordinates.
    pub fn get_world_position(&self) -> Vec3 {
        Vec3::new(
            (self.chunk_position.x * CHUNK_SIZE as i32) as f32,
            (self.chunk_position.y * CHUNK_SIZE as i32) as f32,
            (self.chunk_position.z * CHUNK_SIZE as i32) as f32,
        )
    }

    /// Returns whether this chunk needs to be remeshed.
    pub fn is_dirty(&self) -> bool {
        self.dirty
    }

    /// Marks this chunk as clean (after meshing).
    pub fn mark_clean(&mut self) {
        self.dirty = false;
    }

    /// Checks if this chunk is visible.
    pub fn is_visible(&self) -> bool {
        self.entity.is_some()
    }

    /// Sets the mesh handle for this chunk.
    pub fn set_mesh_handle(&mut self, handle: Handle<Mesh>) {
        self.mesh_handle = Some(handle);
    }

    /// Gets the mesh handle for this chunk.
    pub fn get_mesh_handle(&self) -> Option<Handle<Mesh>> {
        self.mesh_handle.clone()
    }

    /// Sets the entity for this chunk's mesh.
    pub fn set_entity(&mut self, entity: Entity) {
        self.entity = Some(entity);
    }

    /// Gets the entity for this chunk's mesh.
    pub fn get_entity(&self) -> Option<Entity> {
        self.entity
    }

    /// Merges another chunk into this one.
    ///
    /// Non-air voxels from the other chunk will overwrite voxels in this chunk.
    pub fn merge(&mut self, other: VoxelChunk) {
        let mut changed = false;
        for i in 0..CHUNK_VOLUME {
            let other_voxel = other.voxels[i];
            if other_voxel.voxel_type != VoxelType::Air {
                if self.voxels[i] != other_voxel {
                    self.voxels[i] = other_voxel;
                    changed = true;
                }
            }
        }
        if changed {
            self.dirty = true;
        }
        if other.generated {
            self.generated = true;
        }
    }
}

/// The voxel world containing all chunks.
///
/// This is the main data structure for storing a voxel world.
/// It manages all chunks and provides methods for accessing them.
#[derive(Resource, Debug, Clone)]
pub struct VoxelWorld {
    /// All chunks in the world, indexed by chunk position
    chunks: std::collections::HashMap<ChunkPosition, VoxelChunk>,
    /// Chunks that are currently being processed in background tasks
    pending_chunks: std::collections::HashSet<ChunkPosition>,
}

/// Result of a voxel raycast.
#[derive(Debug, Clone, Copy)]
pub struct RaycastHit {
    /// The position of the voxel that was hit
    pub position: VoxelPosition,
    /// The world normal of the face that was hit
    pub normal: Vec3,
}

impl VoxelWorld {
    /// Creates a new empty voxel world.
    pub fn new() -> Self {
        Self {
            chunks: std::collections::HashMap::new(),
            pending_chunks: std::collections::HashSet::new(),
        }
    }

    /// Casts a ray into the voxel world and returns the first solid voxel hit.
    ///
    /// # Arguments
    ///
    /// * `origin` - The starting position of the ray in world coordinates
    /// * `direction` - The normalized direction of the ray
    /// * `max_distance` - The maximum distance to cast
    ///
    /// # Returns
    ///
    /// A RaycastHit if a solid voxel was hit, None otherwise
    pub fn raycast(&self, origin: Vec3, direction: Vec3, max_distance: f32) -> Option<RaycastHit> {
        // Voxel DDA Algorithm
        let mut x = origin.x.floor() as i32;
        let mut y = origin.y.floor() as i32;
        let mut z = origin.z.floor() as i32;

        let step_x = direction.x.signum() as i32;
        let step_y = direction.y.signum() as i32;
        let step_z = direction.z.signum() as i32;

        // t_max is the distance to the first boundary
        // Handle division by zero or very small numbers
        let t_delta_x = if direction.x.abs() < 1e-6 { f32::INFINITY } else { (1.0 / direction.x).abs() };
        let t_delta_y = if direction.y.abs() < 1e-6 { f32::INFINITY } else { (1.0 / direction.y).abs() };
        let t_delta_z = if direction.z.abs() < 1e-6 { f32::INFINITY } else { (1.0 / direction.z).abs() };

        let mut t_max_x = if step_x > 0 { (x as f32 + 1.0 - origin.x) * t_delta_x } else { (origin.x - x as f32) * t_delta_x };
        let mut t_max_y = if step_y > 0 { (y as f32 + 1.0 - origin.y) * t_delta_y } else { (origin.y - y as f32) * t_delta_y };
        let mut t_max_z = if step_z > 0 { (z as f32 + 1.0 - origin.z) * t_delta_z } else { (origin.z - z as f32) * t_delta_z };
        
        // Handle the case where direction is exactly 0 (t_max will be correct via logic below usually, but good to be safe)
        if direction.x == 0.0 { t_max_x = f32::INFINITY; }
        if direction.y == 0.0 { t_max_y = f32::INFINITY; }
        if direction.z == 0.0 { t_max_z = f32::INFINITY; }

        let mut normal = Vec3::ZERO;

        // Limit iterations to avoid infinite loops
        let max_steps = (max_distance * 2.0).ceil() as i32 + 10;
        
        // Current distance traveled along ray
        let mut t = 0.0;

        for _ in 0..max_steps {
            let voxel_pos = VoxelPosition::new(x, y, z);
            if let Some(voxel) = self.get_voxel(&voxel_pos) {
                if voxel.is_solid() {
                    return Some(RaycastHit {
                        position: voxel_pos,
                        normal,
                    });
                }
            }

            if t_max_x < t_max_y {
                if t_max_x < t_max_z {
                    x += step_x;
                    t = t_max_x;
                    t_max_x += t_delta_x;
                    normal = Vec3::new(-step_x as f32, 0.0, 0.0);
                } else {
                    z += step_z;
                    t = t_max_z;
                    t_max_z += t_delta_z;
                    normal = Vec3::new(0.0, 0.0, -step_z as f32);
                }
            } else {
                if t_max_y < t_max_z {
                    y += step_y;
                    t = t_max_y;
                    t_max_y += t_delta_y;
                    normal = Vec3::new(0.0, -step_y as f32, 0.0);
                } else {
                    z += step_z;
                    t = t_max_z;
                    t_max_z += t_delta_z;
                    normal = Vec3::new(0.0, 0.0, -step_z as f32);
                }
            }

            if t > max_distance {
                break;
            }
        }

        None
    }

    /// Marks a chunk as pending background processing.
    pub fn mark_pending(&mut self, pos: ChunkPosition) {
        self.pending_chunks.insert(pos);
    }

    /// Marks a chunk as no longer pending.
    pub fn clear_pending(&mut self, pos: &ChunkPosition) {
        self.pending_chunks.remove(pos);
    }

    /// Checks if a chunk is currently being processed.
    pub fn is_pending(&self, pos: &ChunkPosition) -> bool {
        self.pending_chunks.contains(pos)
    }

    /// Checks if a chunk and all its 6 neighbors are fully generated.
    ///
    /// This is used to ensure we only mesh chunks when they have full context
    /// for proper face culling.
    pub fn is_neighborhood_ready(&self, pos: &ChunkPosition) -> bool {
        let neighbors = [
            *pos,
            ChunkPosition::new(pos.x - 1, pos.y, pos.z),
            ChunkPosition::new(pos.x + 1, pos.y, pos.z),
            ChunkPosition::new(pos.x, pos.y - 1, pos.z),
            ChunkPosition::new(pos.x, pos.y + 1, pos.z),
            ChunkPosition::new(pos.x, pos.y, pos.z - 1),
            ChunkPosition::new(pos.x, pos.y, pos.z + 1),
        ];

        for n_pos in neighbors {
            match self.chunks.get(&n_pos) {
                Some(chunk) => {
                    if !chunk.generated {
                        return false;
                    }
                }
                None => return false,
            }
        }
        true
    }

    /// Gets a chunk at the given chunk position.
    ///
    /// # Arguments
    ///
    /// * `chunk_pos` - The chunk position to get
    ///
    /// # Returns
    ///
    /// A reference to the chunk if it exists, None otherwise
    pub fn get_chunk(&self, chunk_pos: &ChunkPosition) -> Option<&VoxelChunk> {
        self.chunks.get(chunk_pos)
    }

    /// Gets a mutable chunk at the given chunk position.
    ///
    /// If the chunk doesn't exist, it will be created.
    ///
    /// # Arguments
    ///
    /// * `chunk_pos` - The chunk position to get
    ///
    /// # Returns
    ///
    /// A mutable reference to the chunk
    pub fn get_chunk_mut(&mut self, chunk_pos: &ChunkPosition) -> &mut VoxelChunk {
        self.chunks
            .entry(*chunk_pos)
            .or_insert_with(|| VoxelChunk::new(*chunk_pos))
    }

    /// Gets a voxel at the given voxel position.
    ///
    /// # Arguments
    ///
    /// * `voxel_pos` - The voxel position to get
    ///
    /// # Returns
    ///
    /// A reference to the voxel if the chunk exists, None otherwise
    pub fn get_voxel(&self, voxel_pos: &VoxelPosition) -> Option<&Voxel> {
        let chunk_pos = Self::voxel_to_chunk(voxel_pos);
        let local_pos = Self::voxel_to_local(voxel_pos);

        self.get_chunk(&chunk_pos)
            .map(|chunk| chunk.get_voxel(local_pos))
    }

    /// Sets a voxel at the given voxel position.
    ///
    /// If the chunk doesn't exist, it will be created.
    ///
    /// # Arguments
    ///
    /// * `voxel_pos` - The voxel position to set
    /// * `voxel` - The voxel to set
    pub fn set_voxel(&mut self, voxel_pos: &VoxelPosition, voxel: Voxel) {
        let chunk_pos = Self::voxel_to_chunk(voxel_pos);
        let local_pos = Self::voxel_to_local(voxel_pos);

        let chunk = self.get_chunk_mut(&chunk_pos);
        chunk.set_voxel(local_pos, voxel);

        // Mark neighbors as dirty if the voxel is on a boundary
        let size = CHUNK_SIZE as i32;
        if local_pos.x == 0 { self.mark_chunk_dirty(&ChunkPosition::new(chunk_pos.x - 1, chunk_pos.y, chunk_pos.z)); }
        if local_pos.x == size - 1 { self.mark_chunk_dirty(&ChunkPosition::new(chunk_pos.x + 1, chunk_pos.y, chunk_pos.z)); }
        if local_pos.y == 0 { self.mark_chunk_dirty(&ChunkPosition::new(chunk_pos.x, chunk_pos.y - 1, chunk_pos.z)); }
        if local_pos.y == size - 1 { self.mark_chunk_dirty(&ChunkPosition::new(chunk_pos.x, chunk_pos.y + 1, chunk_pos.z)); }
        if local_pos.z == 0 { self.mark_chunk_dirty(&ChunkPosition::new(chunk_pos.x, chunk_pos.y, chunk_pos.z - 1)); }
        if local_pos.z == size - 1 { self.mark_chunk_dirty(&ChunkPosition::new(chunk_pos.x, chunk_pos.y, chunk_pos.z + 1)); }
    }

    /// Marks a specific chunk as dirty.
    pub fn mark_chunk_dirty(&mut self, pos: &ChunkPosition) {
        if let Some(chunk) = self.chunks.get_mut(pos) {
            chunk.dirty = true;
        }
    }

    /// Marks all 6 neighbors of a chunk as dirty.
    pub fn mark_neighbors_dirty(&mut self, pos: &ChunkPosition) {
        let neighbors = [
            ChunkPosition::new(pos.x - 1, pos.y, pos.z),
            ChunkPosition::new(pos.x + 1, pos.y, pos.z),
            ChunkPosition::new(pos.x, pos.y - 1, pos.z),
            ChunkPosition::new(pos.x, pos.y + 1, pos.z),
            ChunkPosition::new(pos.x, pos.y, pos.z - 1),
            ChunkPosition::new(pos.x, pos.y, pos.z + 1),
        ];
        for n_pos in neighbors {
            self.mark_chunk_dirty(&n_pos);
        }
    }

    /// Converts voxel coordinates to chunk coordinates.
    ///
    /// # Arguments
    ///
    /// * `voxel_pos` - The voxel position to convert
    ///
    /// # Returns
    ///
    /// The corresponding chunk position
    pub fn voxel_to_chunk(voxel_pos: &VoxelPosition) -> ChunkPosition {
        ChunkPosition {
            x: voxel_pos.x.div_euclid(CHUNK_SIZE as i32),
            y: voxel_pos.y.div_euclid(CHUNK_SIZE as i32),
            z: voxel_pos.z.div_euclid(CHUNK_SIZE as i32),
        }
    }

    /// Converts voxel coordinates to local chunk coordinates.
    ///
    /// # Arguments
    ///
    /// * `voxel_pos` - The voxel position to convert
    ///
    /// # Returns
    ///
    /// The corresponding local position within the chunk
    pub fn voxel_to_local(voxel_pos: &VoxelPosition) -> VoxelPosition {
        VoxelPosition {
            x: voxel_pos.x.rem_euclid(CHUNK_SIZE as i32),
            y: voxel_pos.y.rem_euclid(CHUNK_SIZE as i32),
            z: voxel_pos.z.rem_euclid(CHUNK_SIZE as i32),
        }
    }

    /// Gets a chunk and its 6 immediate neighbors.
    ///
    /// This is useful for mesh generation to avoid repeated hash map lookups.
    pub fn get_chunk_neighborhood(&self, chunk_pos: &ChunkPosition) -> ChunkNeighborhood<'_> {
        ChunkNeighborhood {
            center: self.chunks.get(chunk_pos),
            neg_x: self.chunks.get(&ChunkPosition::new(chunk_pos.x - 1, chunk_pos.y, chunk_pos.z)),
            pos_x: self.chunks.get(&ChunkPosition::new(chunk_pos.x + 1, chunk_pos.y, chunk_pos.z)),
            neg_y: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y - 1, chunk_pos.z)),
            pos_y: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y + 1, chunk_pos.z)),
            neg_z: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y, chunk_pos.z - 1)),
            pos_z: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y, chunk_pos.z + 1)),
        }
    }

    /// Gets an owned snapshot of a chunk and its 6 immediate neighbors.
    pub fn get_owned_chunk_neighborhood(&self, chunk_pos: &ChunkPosition) -> OwnedChunkNeighborhood {
        OwnedChunkNeighborhood {
            center: self.chunks.get(chunk_pos).cloned(),
            neg_x: self.chunks.get(&ChunkPosition::new(chunk_pos.x - 1, chunk_pos.y, chunk_pos.z)).cloned(),
            pos_x: self.chunks.get(&ChunkPosition::new(chunk_pos.x + 1, chunk_pos.y, chunk_pos.z)).cloned(),
            neg_y: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y - 1, chunk_pos.z)).cloned(),
            pos_y: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y + 1, chunk_pos.z)).cloned(),
            neg_z: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y, chunk_pos.z - 1)).cloned(),
            pos_z: self.chunks.get(&ChunkPosition::new(chunk_pos.x, chunk_pos.y, chunk_pos.z + 1)).cloned(),
        }
    }

    /// Gets all chunks that need to be remeshed.
    ///
    /// # Returns
    ///
    /// A vector of chunk positions that are marked as dirty
    #[instrument(skip(self))]
    pub fn get_dirty_chunks(&self) -> Vec<&ChunkPosition> {
        let dirty_chunks: Vec<_> = self
            .chunks
            .iter()
            .filter(|(_, chunk)| chunk.is_dirty())
            .map(|(pos, _)| pos)
            .collect();

        debug!(
            total_chunks = self.chunks.len(),
            dirty_chunks = dirty_chunks.len(),
            "Retrieved dirty chunks"
        );

        dirty_chunks
    }

    /// Iterates over all chunks in the world.
    pub fn iter_chunks(&self) -> impl Iterator<Item = (&ChunkPosition, &VoxelChunk)> {
        self.chunks.iter()
    }

    /// Iterates over all chunks in the world (mutable).
    pub fn iter_chunks_mut(&mut self) -> impl Iterator<Item = (&ChunkPosition, &mut VoxelChunk)> {
        self.chunks.iter_mut()
    }

    /// Merges another voxel world into this one.
    ///
    /// This will combine the contents of chunks that exist in both worlds.
    pub fn merge(&mut self, other: VoxelWorld) {
        let mut chunks_to_mark_neighbors = Vec::new();
        for (pos, other_chunk) in other.chunks {
            if let Some(self_chunk) = self.chunks.get_mut(&pos) {
                let was_generated = self_chunk.generated;
                self_chunk.merge(other_chunk);
                // If it just finished generating, we need to refresh neighbors
                if !was_generated && self_chunk.generated {
                    chunks_to_mark_neighbors.push(pos);
                }
            } else {
                let is_generated = other_chunk.generated;
                self.chunks.insert(pos, other_chunk);
                // If a new fully generated chunk appeared, mark neighbors
                if is_generated {
                    chunks_to_mark_neighbors.push(pos);
                }
            }
        }

        for pos in chunks_to_mark_neighbors {
            self.mark_neighbors_dirty(&pos);
        }
    }

    /// Gets the total number of chunks in the world.
    pub fn chunk_count(&self) -> usize {
        self.chunks.len()
    }

    /// Gets the number of visible chunks.
    pub fn visible_chunk_count(&self) -> usize {
        self.chunks
            .values()
            .filter(|chunk| chunk.is_visible())
            .count()
    }

    /// Gets the number of dirty chunks.
    pub fn dirty_chunk_count(&self) -> usize {
        self.chunks
            .values()
            .filter(|chunk| chunk.is_dirty())
            .count()
    }
}

/// Trait for unified access to voxels in a neighborhood.
pub trait VoxelAccess {
    fn get_voxel(&self, local_pos: VoxelPosition) -> Option<&Voxel>;
}

impl<'a> VoxelAccess for ChunkNeighborhood<'a> {
    fn get_voxel(&self, local_pos: VoxelPosition) -> Option<&Voxel> {
        self.get_voxel(local_pos)
    }
}

impl VoxelAccess for OwnedChunkNeighborhood {
    fn get_voxel(&self, local_pos: VoxelPosition) -> Option<&Voxel> {
        self.get_voxel(local_pos)
    }
}

/// A chunk and its 6 immediate neighbors, owning its data.
///
/// This is used to pass a snapshot of a neighborhood to a background task
/// without needing to clone the entire world.
pub struct OwnedChunkNeighborhood {
    pub center: Option<VoxelChunk>,
    pub neg_x: Option<VoxelChunk>,
    pub pos_x: Option<VoxelChunk>,
    pub neg_y: Option<VoxelChunk>,
    pub pos_y: Option<VoxelChunk>,
    pub neg_z: Option<VoxelChunk>,
    pub pos_z: Option<VoxelChunk>,
}

impl OwnedChunkNeighborhood {
    /// Gets a voxel at the given world-relative position within the neighborhood.
    pub fn get_voxel(&self, local_pos: VoxelPosition) -> Option<&Voxel> {
        if (0..CHUNK_SIZE as i32).contains(&local_pos.x)
            && (0..CHUNK_SIZE as i32).contains(&local_pos.y)
            && (0..CHUNK_SIZE as i32).contains(&local_pos.z)
        {
            return self.center.as_ref().map(|c| c.get_voxel(local_pos));
        }

        // Check neighbors
        if local_pos.x < 0 {
            self.neg_x.as_ref().map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x + CHUNK_SIZE as i32,
                    local_pos.y,
                    local_pos.z,
                ))
            })
        } else if local_pos.x >= CHUNK_SIZE as i32 {
            self.pos_x.as_ref().map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x - CHUNK_SIZE as i32,
                    local_pos.y,
                    local_pos.z,
                ))
            })
        } else if local_pos.y < 0 {
            self.neg_y.as_ref().map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y + CHUNK_SIZE as i32,
                    local_pos.z,
                ))
            })
        } else if local_pos.y >= CHUNK_SIZE as i32 {
            self.pos_y.as_ref().map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y - CHUNK_SIZE as i32,
                    local_pos.z,
                ))
            })
        } else if local_pos.z < 0 {
            self.neg_z.as_ref().map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y,
                    local_pos.z + CHUNK_SIZE as i32,
                ))
            })
        } else if local_pos.z >= CHUNK_SIZE as i32 {
            self.pos_z.as_ref().map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y,
                    local_pos.z - CHUNK_SIZE as i32,
                ))
            })
        } else {
            None
        }
    }
}

/// A chunk and its 6 immediate neighbors.
///
/// This is used to provide efficient access to adjacent voxels
/// during mesh generation, avoiding repeated HashMap lookups.
pub struct ChunkNeighborhood<'a> {
    pub center: Option<&'a VoxelChunk>,
    pub neg_x: Option<&'a VoxelChunk>,
    pub pos_x: Option<&'a VoxelChunk>,
    pub neg_y: Option<&'a VoxelChunk>,
    pub pos_y: Option<&'a VoxelChunk>,
    pub neg_z: Option<&'a VoxelChunk>,
    pub pos_z: Option<&'a VoxelChunk>,
}

impl<'a> ChunkNeighborhood<'a> {
    /// Gets a voxel at the given world-relative position within the neighborhood.
    ///
    /// The position is relative to the center chunk's (0,0,0).
    pub fn get_voxel(&self, local_pos: VoxelPosition) -> Option<&Voxel> {
        if (0..CHUNK_SIZE as i32).contains(&local_pos.x)
            && (0..CHUNK_SIZE as i32).contains(&local_pos.y)
            && (0..CHUNK_SIZE as i32).contains(&local_pos.z)
        {
            return self.center.map(|c| c.get_voxel(local_pos));
        }

        // Check neighbors
        if local_pos.x < 0 {
            self.neg_x.map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x + CHUNK_SIZE as i32,
                    local_pos.y,
                    local_pos.z,
                ))
            })
        } else if local_pos.x >= CHUNK_SIZE as i32 {
            self.pos_x.map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x - CHUNK_SIZE as i32,
                    local_pos.y,
                    local_pos.z,
                ))
            })
        } else if local_pos.y < 0 {
            self.neg_y.map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y + CHUNK_SIZE as i32,
                    local_pos.z,
                ))
            })
        } else if local_pos.y >= CHUNK_SIZE as i32 {
            self.pos_y.map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y - CHUNK_SIZE as i32,
                    local_pos.z,
                ))
            })
        } else if local_pos.z < 0 {
            self.neg_z.map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y,
                    local_pos.z + CHUNK_SIZE as i32,
                ))
            })
        } else if local_pos.z >= CHUNK_SIZE as i32 {
            self.pos_z.map(|c| {
                c.get_voxel(VoxelPosition::new(
                    local_pos.x,
                    local_pos.y,
                    local_pos.z - CHUNK_SIZE as i32,
                ))
            })
        } else {
            None
        }
    }
}

impl Default for VoxelWorld {
    fn default() -> Self {
        Self::new()
    }
}
